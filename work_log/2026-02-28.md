# 2026-02-28

## 작업 내용

### 1. 지속성 계층 아키텍처 전환: IndexedDB → AWS DynamoDB/S3

프론트엔드의 데이터 소스를 전환하는 대규모 리팩토링 완료.

**변경 전:**
- 모든 데이터(works, episodes, plots, characters, relations)를 IndexedDB(`idb` 라이브러리)에 저장
- 플롯 본문만 500ms debounce로 SQLite(Tauri) 및 S3(fire-and-forget)에 동시 저장
- 전역 저장 메커니즘 없음

**변경 후:**
- IndexedDB 완전 제거 (`idb` 패키지 언인스톨)
- `src/db/index.ts` — TypeScript 타입 정의만 유지 (CRUD 함수 제거)
- 새 `src/api/index.ts` — AWS REST API 호출 레이어 (DynamoDB/S3 응답 정규화)
- Zustand 스토어 완전 재작성: 대기 중인 변경사항 큐(pending mutation queues) 도입
- 전역 Save 버튼 (`Cmd+S` / 클릭) → `saveAll(workId)` 호출 시에만 데이터 AWS에 저장
- **중요**: 데이터는 명시적 저장 시에만 클라우드에 지속됨 (온라인 시 자동 미러링 아님)

### 2. 새 파일: `src/api/index.ts` (~200줄)

AWS REST API와 통신하는 중앙 집중식 API 계층.

**핵심 함수들:**

- **Fetch 래퍼**
  - `apiFetch(path, options)` — credentials 포함, 에러 시 상태코드와 함께 throw

- **응답 정규화 함수들** — DynamoDB의 `local_id` 필드를 Zustand 스토어의 `id` 필드로 변환
  - `normalizeWork(item)`, `normalizeEpisode(item)`, `normalizePlot(item)`, `normalizeCharacter(item)`, `normalizeRelation(item)`

- **인증**
  - `fetchMe()` — 현재 사용자 정보 (`{sub, email}`) 반환

- **Works**
  - `fetchWorks()` → 배열 반환
  - `apiCreateWork(work)` → 생성된 work 반환
  - `apiUpdateWork(workId, updates)` → 업데이트된 work 반환
  - `apiDeleteWork(workId)` → 무반환

- **Episodes**
  - `fetchEpisodes(workId)` → 배열 반환
  - `apiCreateEpisode(workId, episode)` → 생성된 episode 반환
  - `apiUpdateEpisode(episodeId, updates)` → 업데이트된 episode 반환
  - `apiDeleteEpisode(episodeId)` → 무반환

- **Plots** (메타 + 콘텐츠 분리 저장)
  - `fetchPlots(episodeId)` → 메타데이터 배열 (DynamoDB에서)
  - `fetchPlotContent(plotId)` → S3에서 TipTap JSON 로드 (병렬)
  - `apiCreatePlot(episodeId, plot)` → 생성된 plot 반환
  - `apiUpdatePlotMeta(plotId, updates)` → 업데이트된 plot 반환
  - `apiSavePlotContent(plotId, content)` → S3에 TipTap JSON 저장, DynamoDB `updated_at` 동시 업데이트
  - `apiDeletePlot(plotId)` → S3 오브젝트도 함께 삭제

- **Characters**
  - `fetchCharacters(workId)` → 배열 반환
  - `apiCreateCharacter(workId, character)` → 생성된 character 반환
  - `apiUpdateCharacter(characterId, updates)` → 업데이트된 character 반환
  - `apiDeleteCharacter(characterId)` → 무반환

- **Relations**
  - `fetchRelations(workId)` → 배열 반환
  - `apiCreateRelation(workId, relation)` → 생성된 relation 반환
  - `apiDeleteRelation(relationId)` → 무반환

### 3. 수정: `src/db/index.ts` — 타입 정의만 유지

이전 SQLite CRUD 함수 모두 제거:
- `import { openDB, IDBPDatabase } from 'idb'` 제거
- `getDb()` 함수 제거
- 모든 CRUD 함수 제거 (`createWork`, `updateWork` 등)

유지:
- TypeScript 인터페이스: `WorkType`, `Work`, `Episode`, `Plot`, `Character`, `CharacterRelation`

### 4. 수정: `src/store/index.ts` — 완전 재작성 (~500줄)

**새로운 상태 필드:**

```typescript
// 인증
isLoggedIn: boolean
userEmail: string | null

// 저장 상태
isDirty: boolean         // 저장하지 않은 변경사항 있음
isSaving: boolean        // 현재 저장 중

// 대기 중인 변경사항 큐 (API 호출 시점에만 실행)
pendingCreates: {
  works: Work[]
  episodes: Episode[]
  plots: Plot[]
  characters: Character[]
  relations: CharacterRelation[]
}

pendingUpdates: {
  works: Work[]
  episodes: Episode[]
  plots: Plot[]
  characters: Character[]
}

pendingDeletes: {
  works: number[]
  episodes: number[]
  plots: number[]
  characters: number[]
  relations: number[]
}

// 콘텐츠 변경사항 추적
dirtyPlotContents: Set<number>  // plotId 세트
```

**클라이언트 ID 생성:**
- `newId() = Date.now()` — 밀리초 타임스탬프를 정수 ID로 사용
- JS의 안전한 정수 범위 내에서 유일성 보장 (단일 사용자)

**모든 변경 작업 흐름:**
1. 메모리의 상태 즉시 업데이트 (optimistic update)
2. 변경사항을 대기 중 큐에 추가
3. `isDirty = true` 설정 (API 호출 없음)

예시:
```typescript
createWork: (work) => {
  const newWork = { ...work, id: newId() }
  store.works.push(newWork)
  store.pendingCreates.works.push(newWork)
  store.isDirty = true
  return newWork.id
}
```

**새 액션: `saveAll(workId)`** — 모든 변경사항을 AWS에 저장

1. **큐 정리 (Net-zero 최적화)**
   - 같은 ID가 create + delete에 모두 있으면 둘 다 제거 (API 호출 0)
   - `pendingUpdates`에 있는 ID가 `pendingCreates`에 있으면 `pendingUpdates`에서 제거 (create가 이미 최신 상태 전송)

2. **삭제 (순서 중요 — 외래키 제약)**
   - 관계 → 캐릭터 → 플롯 → 에피소드 → 작품

3. **생성 (순서 중요 — 부모 의존)**
   - 작품 → 에피소드 → 플롯 → 캐릭터 → 관계

4. **업데이트 (병렬)**
   - works, episodes, plots, characters 동시 업데이트

5. **S3 콘텐츠 저장 (병렬)**
   - `dirtyPlotContents`의 모든 plotId에 대해 `apiSavePlotContent` 호출
   - 삭제된 plot은 제외

6. **완료**
   - 모든 큐 초기화
   - `isDirty = false`, `isSaving = false`

**에러 처리:**
- API 호출 실패 시 `isSaving = false` 설정하되 큐는 유지 (재시도 가능)

**새 액션들:**

- `loadUserInfo()` — `/me` 엔드포인트 호출, `isLoggedIn/userEmail` 설정
- `setPlotContent(plotId, content)` — 에디터에서 호출, `dirtyPlotContents` 추가 (save 시 S3 저장)
- `reorderEpisodes(workId, reordered)` — 드래그로 에피소드 순서 변경, 메모리 + `pendingUpdates`에만 저장
- `discardPending()` — 모든 대기 중인 변경사항 버림 (선택 작품 변경 시 unsaved 작품 생성/삭제 롤백)

**선택 작품 변경 (dirty check):**
```typescript
selectWork: (id) => {
  if (store.isDirty) {
    const ok = window.confirm('저장하지 않은 변경사항이 있습니다. 버리시겠습니까?')
    if (!ok) return
    store.discardPending()
    // 메모리의 unsaved 생성/삭제 제거 후
    store.loadWorks()  // 다시 로드
  }
  store.selectedWorkId = id
}
```

**캐스케이드 삭제:**
```typescript
deleteWork: (workId) => {
  // 1. 메모리에서 work 제거
  // 2. 해당 work의 모든 episode 찾기
  // 3. 각 episode의 모든 plot 찾기
  // 4. 각 plot의 모든 character 및 relation 찾기
  // 5. 메모리와 pendingDeletes에 계층별로 추가
  // 6. pendingCreates에 있으면 제거 (생성 취소)
}
```

**캐릭터 이름/색상 변경 시 대화 노드 동기화:**
```typescript
updateCharacter: (characterId, updates) => {
  const oldCharacter = findCharacter(characterId)
  const newCharacter = { ...oldCharacter, ...updates }

  // 메모리에 모든 plot의 dialogue 노드 업데이트
  // characterName 또는 characterColor 변경 시
  // → 해당 dialogue 노드 속성 수정
  // → 해당 plot을 dirtyPlotContents에 추가

  // 대기 큐에도 추가
}
```

**`loadPlots(episodeId)` 최적화:**
- DynamoDB에서 메타데이터만 먼저 로드
- 그 후 모든 plot의 S3 콘텐츠를 병렬로 fetch

### 5. 수정: `src/App.tsx`

**마운트 시 초기화:**
```typescript
useEffect(() => {
  ;(async () => {
    await store.loadUserInfo()
    if (store.isLoggedIn) {
      await store.loadWorks()
    }
  })()
}, [])
```

**저장하지 않은 변경사항 보호:**
```typescript
useEffect(() => {
  const handleBeforeUnload = (e: BeforeUnloadEvent) => {
    if (store.isDirty) {
      e.preventDefault()
      e.returnValue = ''
    }
  }
  window.addEventListener('beforeunload', handleBeforeUnload)
  return () => window.removeEventListener('beforeunload', handleBeforeUnload)
}, [store.isDirty])
```

**키보드 단축키: `Cmd+S` / `Ctrl+S`**
```typescript
useEffect(() => {
  const handleKeyDown = (e: KeyboardEvent) => {
    if ((e.metaKey || e.ctrlKey) && e.key === 's') {
      e.preventDefault()
      if (store.selectedWorkId && store.isLoggedIn && !store.isSaving) {
        store.saveAll(store.selectedWorkId)
      }
    }
  }
  window.addEventListener('keydown', handleKeyDown)
  return () => window.removeEventListener('keydown', handleKeyDown)
}, [store.selectedWorkId, store.isLoggedIn, store.isSaving])
```

**Save 버튼** — 우측 패널 헤더 (탭과 내보내기 버튼 사이)

```typescript
{store.selectedWorkId && store.isLoggedIn && (
  <button
    onClick={() => store.saveAll(store.selectedWorkId!)}
    disabled={!store.isDirty || store.isSaving}
    className={
      store.isSaving ? 'text-gray-500 cursor-not-allowed' :
      store.isDirty ? 'text-[#AD1B02] hover:text-[#c72e05]' :
      'text-gray-400 cursor-not-allowed'
    }
  >
    {store.isSaving ? '저장 중...' : store.isDirty ? '저장 •' : '저장됨 ✓'}
  </button>
)}
```

상태:
- `저장됨 ✓` — 회색, 비활성화 (isDirty=false)
- `저장 •` — 빨강(#AD1B02), 클릭 가능 (isDirty=true)
- `저장 중...` — 회색, 비활성화 (isSaving=true)

### 6. 수정: `src/components/Sidebar/index.tsx`

**제거:**
- 로컬 `userEmail` 상태
- 마운트 시 `useEffect(() => fetch('/me'))` (App.tsx에서 담당)
- `loadWorks` 마운트 호출 (App.tsx에서 담당)

**변경:**
- `useStore()` 에서 `isLoggedIn`, `userEmail` 직접 읽기
- 사용자 정보 표시 로직은 유지

### 7. 수정: 에디터 컴포넌트들 — 500ms debounce 제거

**`src/components/Editor/index.tsx`**
```typescript
// Before
const debouncedSave = useMemo(() => debounce((content) => {
  updatePlot(activePlotId, { content })
  // + fire-and-forget PUT /plots/{id}/content
}, 500), [activePlotId])

// After
const handleUpdate = () => {
  if (activePlotId) {
    store.setPlotContent(activePlotId, editor.getJSON())
  }
}

editor.on('update', handleUpdate)
```

**`src/components/NovelEditor/index.tsx`**
- 같은 방식: `setPlotContent(chapterPlotId, content)` 즉시 호출

**`src/components/Editor/PlotEditorSection.tsx`**
- 같은 방식

**`src/components/NovelEditor/ChapterEditorSection.tsx`**
- 같은 방식

### 8. 수정: `src/components/NovelEditor/ChapterList.tsx` — drag end 핸들러

**제거:**
- `import { updateEpisodeOrder } from '../../db'`

**변경:**
```typescript
// Before (async 루프)
const handleDragEnd = async (e) => {
  const reordered = arrayMove(chapters, activeIndex, overIndex)
  for (const [i, ch] of reordered.entries()) {
    await updateEpisodeOrder(ch.id, i)
  }
  setChapters(reordered)
}

// After (동기 호출)
const handleDragEnd = (e) => {
  const reordered = arrayMove(chapters, activeIndex, overIndex)
  store.reorderEpisodes(store.selectedWorkId!, reordered)
}
```

### 9. 수정: `src/components/PlanningDoc/index.tsx`

500ms debounce 제거. TipTap 에디터 `onUpdate` 콜백:
```typescript
const handleUpdate = () => {
  store.savePlanningDoc(selectedWorkId, editor.getJSON())
}
```

(참고: `savePlanningDoc`은 메모리 + `pendingUpdates`에만 저장, API 호출 아님)

### 10. 수정: `src/components/CharacterDetail/index.tsx` — 이미지 동기화 WIP

이미지 업로드 영역 라벨 옆에 WIP 배지:
```typescript
<label className="text-sm text-gray-600">
  이미지 <span className="text-[#E88D14]">동기화 준비 중</span>
</label>
```

(S3 이미지 업로드는 추후 구현 예정)

### 11. 수정: `backend/main.py` — Planning Doc 필드 추가

**`POST /works`:**
```python
item = {
  'work_id': work_id,
  'user_id': user_sub,
  'name': body.get('name'),
  'type': body.get('type', 'plot'),
  'planning_doc': body.get('planning_doc', '{}'),  # NEW
  'created_at': timestamp,
  'updated_at': timestamp
}
```

**`PUT /works/{work_id}`:**
```python
update_expr = 'SET #n = :n, #t = :t, #pd = :pd, updated_at = :ua'
expr_values = {
  ':n': name,
  ':t': work_type,
  ':pd': planning_doc,  # NEW
  ':ua': timestamp
}
```

### 12. 패키지 변경

```bash
npm uninstall idb
```

IndexedDB 라이브러리 완전 제거.

### 13. 빌드 및 배포

**`npm run build` 결과:**
- ✅ TypeScript 에러 0개
- ✅ 컴파일 경고 0개

**Git commit:**
- Commit hash: 3b85cc4
- 메시지: "feat: IndexedDB → AWS DynamoDB/S3 마이그레이션, 전역 Save 버튼 추가"

**배포:**
- **프론트엔드**: Vercel 자동 배포 (github main push 후)
- **백엔드**: `cd backend && serverless deploy` 필요 (planning_doc 테이블 스키마 변경 적용)

## 결정 사항

### 1. Dual-Write에서 Single-Write로 전환

이전(2026-02-27):
- 로컬 SQLite와 DynamoDB/S3를 동시에 기록하는 "dual-write" 패턴
- 온라인/오프라인 둘 다 동작하나 클라우드 오류가 편집을 방해하지 않음

현재(2026-02-28):
- 명시적 저장(`saveAll`) 시에만 DynamoDB/S3에 기록 (single-write)
- 로컬 메모리만 사용 (SQLite/IndexedDB 제거)
- 오프라인 작동 불가능 (향후 SQLite 복원 고려)

**장점:**
- 로컬/클라우드 상태 불일치 문제 완전 제거
- 사용자가 저장 시점을 명시적으로 제어
- API 호출 횟수 감소 (debounce 제거)
- 코드 복잡도 감소

**단점:**
- 오프라인 작동 불가능 (현재 버전)

### 2. 클라이언트 ID 생성 전략

`Date.now()` (밀리초 타임스탐프) 선택:
- `newId() = Date.now()` — 정수, JS의 안전한 범위, 유일성 보장(단일 사용자)
- UUID 대신 채택한 이유: 필드 크기 작음, 정렬 가능, 가독성 좋음

### 3. API 호출 순서 최적화

**삭제:** 관계 → 캐릭터 → 플롯 → 에피소드 → 작품
- 외래키 제약 고려 (역방향 순서)

**생성:** 작품 → 에피소드 → 플롯 → 캐릭터 → 관계
- 부모 의존성 순서

**업데이트 + S3 콘텐츠:** 병렬 처리
- 각 작품/에피소드/플롯은 독립적
- S3는 클라우드이므로 로컬 상태와 무관

### 4. 플롯 콘텐츠 로드 최적화

```typescript
loadPlots(episodeId) {
  // 1단계: DynamoDB에서 메타 로드
  const metas = await fetchPlots(episodeId)

  // 2단계: 각 plot의 S3 콘텐츠 병렬 로드
  const contents = await Promise.all(
    metas.map(m => fetchPlotContent(m.id))
  )

  // 3단계: 병합
}
```

S3 fetch를 병렬로 처리하여 총 로드 시간 단축.

### 5. 캐릭터 이름/색상 변경 시 대화 노드 동기화

메모리 내 모든 플롯의 TipTap editor를 순회하며 dialogue 노드 속성 업데이트:
```typescript
// characterName: "Alice" → "Bob" 변경 시
plots.forEach(plot => {
  plot.content.forEach(node => {
    if (node.type === 'dialogue' && node.attrs.characterName === oldName) {
      node.attrs.characterName = newName
      node.attrs.characterColor = newColor
    }
  })
  // 해당 plot을 dirtyPlotContents에 추가
})
```

이는 에디터 UI는 업데이트되지 않으나(별도 탭이므로) save 시 올바른 이름/색상으로 S3에 저장됨.

### 6. Big Batch Save 아키텍처

`saveAll(workId)` 단일 함수로 모든 변경사항 일괄 저장:
- 사용자가 저장을 클릭했을 때만 모든 API 호출 발생
- 부분 실패 가능성 있음 (예: character 생성 성공, relation 생성 실패)
- 향후 트랜잭션 또는 재시도 로직 고려

## 이슈/메모

### 1. 기존 DynamoDB 데이터 마이그레이션 불가능

**문제:**
- DynamoDB `works` 테이블이 기존 사용자들에게 비어 있음
- 이전 앱은 plot 콘텐츠만 fire-and-forget으로 S3에 저장했고, works/episodes 메타는 IndexedDB(로컬 브라우저)에만 있었음
- 로컬 IndexedDB 데이터를 DynamoDB로 자동 마이그레이션할 수 없음

**해결:**
- 기존 사용자는 새로운 앱에서 작품을 새로 만들고 클릭 후 Save 해야 함
- 향후 마이그레이션 유틸리티 고려 (복잡도 높음)

**영향:**
- 기존 S3의 plot 콘텐츠(`plots/{sub}/*.json`)는 고아 데이터로 남음
- 정리 필요 (추후 관리 스크립트 작성 권장)

### 2. 오프라인 작동 불가능

현재 구조는 AWS 인증 및 저장이 필수이므로 인터넷 연결 필수.

향후:
- SQLite 복원 고려 (Tauri 앱만)
- 로컬 변경 → 온라인 복귀 시 동기화 메커니즘

### 3. 에러 처리 개선 필요

현재 `saveAll` 중 API 실패 시:
- 큐는 유지되지만 사용자에게 에러 메시지 표시 미흡
- Retry UI 미구현

향후 개선:
- Toast/Snackbar로 저장 성공/실패 알림
- 재시도 버튼

### 4. 부분 저장 실패 처리

예시: Create works 성공, Create episodes 실패
- 부분적으로 생성된 데이터 상태 불일치
- Rollback 메커니즘 고려 필요

현재: 큐 유지 → 사용자가 수동으로 저장 재시도

### 5. 캐릭터 이름 변경의 대화 노드 동기화 한계

메모리 내 동기화는 되나 다른 탭/창에서 편집 중인 경우:
- 크로스 탭 상태 동기화 미흡
- Broadcast Channel / SharedWorker 고려 필요

현재: 같은 탭 내에서만 정확함

### 6. Planning Doc 필드 추가

`backend/main.py`와 `src/store/index.ts`에 `planning_doc` 필드 추가했으나:
- 프론트엔드 `PlanningDoc` 컴포넌트는 현재 메모리만 저장 (AWS 저장 아직)
- Save 버튼 클릭 시 `works` 테이블에 포함되어 함께 저장됨

### 7. TypeScript strict 모드 고려

`src/store/index.ts`에서 여러 곳에 `!` (non-null assertion) 사용:
```typescript
store.saveAll(store.selectedWorkId!)
```

향후:
- Optional chaining + nullish coalescing으로 개선
- 타입 안전성 강화

### 8. 전역 상태 선택 함수 추가 권장

현재:
```typescript
const isDirty = useStore(s => s.isDirty)
const isSaving = useStore(s => s.isSaving)
// ... 여러 번 호출
```

향후:
```typescript
const { isDirty, isSaving } = useStore(s => ({
  isDirty: s.isDirty,
  isSaving: s.isSaving
}))
```

또는 Zustand의 `useShallow` 사용.

## 다음 작업

1. **오프라인 지원 복원** — SQLite 재도입 (Tauri only)
   - 로컬 변경 → 온라인 복귀 시 동기화

2. **에러 처리 UI**
   - Toast로 저장 성공/실패 알림
   - Retry 버튼

3. **이미지 동기화** — S3 이미지 업로드
   - 캐릭터 아바타 이미지 저장
   - 메타데이터와 함께 저장

4. **기존 데이터 마이그레이션 유틸리티**
   - IndexedDB → DynamoDB 마이그레이션 스크립트

5. **성능 최적화**
   - 대량의 plot 콘텐츠 로드 시 스트리밍 고려
   - S3 fetch 병렬도 제한 (예: 동시 5개)

6. **DynamoDB 테이블 구조 개선**
   - 계정별 권한 세분화 (현재 모든 사용자가 모든 테이블 읽기 가능)
   - TTL 설정 (미사용 데이터 자동 정리)

7. **Tauri 오프라인 바이너리 빌드 및 배포**
   - 현재 `npm run tauri build` 미확인 (Mac 환경)
   - Rust 환경 검증 후 릴리스

## 파일 변경 요약

| 파일 | 유형 | 라인 수 |
|---|---|---|
| `src/api/index.ts` | 신규 | ~200 |
| `src/db/index.ts` | 대폭 축소 | ~50 (이전 ~200) |
| `src/store/index.ts` | 완전 재작성 | ~500 (이전 ~350) |
| `src/App.tsx` | 수정 | +30 라인 |
| `src/components/Sidebar/index.tsx` | 수정 | -10 라인 |
| `src/components/Editor/index.tsx` | 수정 | -15 라인 |
| `src/components/NovelEditor/index.tsx` | 수정 | -15 라인 |
| `src/components/Editor/PlotEditorSection.tsx` | 수정 | -15 라인 |
| `src/components/NovelEditor/ChapterEditorSection.tsx` | 수정 | -15 라인 |
| `src/components/NovelEditor/ChapterList.tsx` | 수정 | -10 라인 |
| `src/components/PlanningDoc/index.tsx` | 수정 | -15 라인 |
| `src/components/CharacterDetail/index.tsx` | 수정 | +3 라인 |
| `backend/main.py` | 수정 | +5 라인 |
| `package.json` | 수정 | -1 라인 (idb 제거) |

**총 변경:** ~700 라인 (신규 + 수정)

